"# fd\n[![Build Status](https://travis-ci.org/sharkdp/fd.svg?branch=master)](https://travis-ci.org/sharkdp/fd)\n[![Build status](https://ci.appveyor.com/api/projects/status/21c4p5fwggc5gy3j/branch/master?svg=true)](https://ci.appveyor.com/project/sharkdp/fd/branch/master)\n[![Version info](https://img.shields.io/crates/v/fd-find.svg)](https://crates.io/crates/fd-find)\n[\u4e2d\u6587](https://github.com/chinanf-boy/fd-zh)\n[\ud55c\uad6d\uc5b4](https://github.com/spearkkk/fd-kor)\n\n*fd* is a simple, fast and user-friendly alternative to\n[*find*](https://www.gnu.org/software/findutils/).\n\nWhile it does not seek to mirror all of *find*'s powerful functionality, it provides sensible\n(opinionated) defaults for [80%](https://en.wikipedia.org/wiki/Pareto_principle) of the use cases.\n\n## Features\n* Convenient syntax: `fd PATTERN` instead of `find -iname '*PATTERN*'`.\n* Colorized terminal output (similar to *ls*).\n* It's *fast* (see [benchmarks](#benchmark) below).\n* Smart case: the search is case-insensitive by default. It switches to\n  case-sensitive if the pattern contains an uppercase\n  character[\\*](http://vimdoc.sourceforge.net/htmldoc/options.html#'smartcase').\n* Ignores hidden directories and files, by default.\n* Ignores patterns from your `.gitignore`, by default.\n* Regular expressions.\n* Unicode-awareness.\n* The command name is *50%* shorter[\\*](https://github.com/ggreer/the_silver_searcher) than\n  `find` :-).\n* Parallel command execution with a syntax similar to GNU Parallel.\n\n## Demo\n\n![Demo](doc/screencast.svg)\n\n## Benchmark\n\nLet's search my home folder for files that end in `[0-9].jpg`. It contains ~190.000\nsubdirectories and about a million files. For averaging and statistical analysis, I'm using\n[hyperfine](https://github.com/sharkdp/hyperfine). The following benchmarks are performed\nwith a \"warm\"/pre-filled disk-cache (results for a \"cold\" disk-cache show the same trends).\n\nLet's start with `find`:\n```\nBenchmark #1: find ~ -iregex '.*[0-9]\\.jpg$'\n\n  Time (mean \u00b1 \u03c3):      7.236 s \u00b1  0.090 s\n\n  Range (min \u2026 max):    7.133 s \u2026  7.385 s\n```\n\n`find` is much faster if it does not need to perform a regular-expression search:\n```\nBenchmark #2: find ~ -iname '*[0-9].jpg'\n\n  Time (mean \u00b1 \u03c3):      3.914 s \u00b1  0.027 s\n\n  Range (min \u2026 max):    3.876 s \u2026  3.964 s\n```\n\nNow let's try the same for `fd`. Note that `fd` *always* performs a regular expression\nsearch. The options `--hidden` and `--no-ignore` are needed for a fair comparison,\notherwise `fd` does not have to traverse hidden folders and ignored paths (see below):\n```\nBenchmark #3: fd -HI '.*[0-9]\\.jpg$' ~\n\n  Time (mean \u00b1 \u03c3):     811.6 ms \u00b1  26.9 ms\n\n  Range (min \u2026 max):   786.0 ms \u2026 870.7 ms\n```\nFor this particular example, `fd` is approximately nine times faster than `find -iregex`\nand about five times faster than `find -iname`. By the way, both tools found the exact\nsame 20880 files :smile:.\n\nFinally, let's run `fd` without `--hidden` and `--no-ignore` (this can lead to different\nsearch results, of course). If *fd* does not have to traverse the hidden and git-ignored\nfolders, it is almost an order of magnitude faster:\n```\nBenchmark #4: fd '[0-9]\\.jpg$' ~\n\n  Time (mean \u00b1 \u03c3):     123.7 ms \u00b1   6.0 ms\n\n  Range (min \u2026 max):   118.8 ms \u2026 140.0 ms\n```\n\n**Note**: This is *one particular* benchmark on *one particular* machine. While I have\nperformed quite a lot of different tests (and found consistent results), things might\nbe different for you! I encourage everyone to try it out on their own. See\n[this repository](https://github.com/sharkdp/fd-benchmarks) for all necessary scripts.\n\nConcerning *fd*'s speed, the main credit goes to the `regex` and `ignore` crates that are also used\nin [ripgrep](https://github.com/BurntSushi/ripgrep) (check it out!).\n\n## Colorized output\n`fd` can colorize files by extension, just like `ls`. In order for this to work, the environment\nvariable [`LS_COLORS`](https://linux.die.net/man/5/dir_colors) has to be set. Typically, the value\nof this variable is set by the `dircolors` command which provides a convenient configuration format\nto define colors for different file formats.\nOn most distributions, `LS_COLORS` should be set already. If you are on Windows or if you are looking\nfor alternative, more complete (or more colorful) variants, see [here](https://github.com/sharkdp/vivid),\n[here](https://github.com/seebi/dircolors-solarized) or\n[here](https://github.com/trapd00r/LS_COLORS).\n\n`fd` also honors the [`NO_COLOR`](https://no-color.org/) environment variable.\n\n## Parallel command execution\nIf the `-x`/`--exec` option is specified alongside a command template, a job pool will be created\nfor executing commands in parallel for each discovered path as the input. The syntax for generating\ncommands is similar to that of GNU Parallel:\n\n- `{}`: A placeholder token that will be replaced with the path of the search result\n  (`documents/images/party.jpg`).\n- `{.}`: Like `{}`, but without the file extension (`documents/images/party`).\n- `{/}`: A placeholder that will be replaced by the basename of the search result (`party.jpg`).\n- `{//}`: Uses the parent of the discovered path (`documents/images`).\n- `{/.}`: Uses the basename, with the extension removed (`party`).\n\n``` bash\n# Convert all jpg files to png files:\nfd -e jpg -x convert {} {.}.png\n\n# Unpack all zip files (if no placeholder is given, the path is appended):\nfd -e zip -x unzip\n\n# Convert all flac files into opus files:\nfd -e flac -x ffmpeg -i {} -c:a libopus {.}.opus\n\n# Count the number of lines in Rust files (the command template can be terminated with ';'):\nfd -x wc -l \\; -e rs\n```\n\nThe number of threads used for command execution can be set with the `--threads`/`-j` option.\n\n## Installation\n\n[![Packaging status](https://repology.org/badge/vertical-allrepos/fd-find.svg)](https://repology.org/project/fd-find/versions)\n\n### On Ubuntu\n*... and other Debian-based Linux distributions.*\n\nIf you run Ubuntu 19.04 (Disco Dingo) or newer, you can install the\n[officially maintained package](https://packages.ubuntu.com/fd-find):\n```\nsudo apt install fd-find\n```\nNote that the binary is called `fdfind` as the binary name `fd` is already used by another package.\nIt is recommended that you add an `alias fd=fdfind` to your shells initialization file, in order to\nuse `fd` in the same way as in this documentation.\n\nIf you use an older version of Ubuntu, you can download the latest `.deb` package from the\n[release page](https://github.com/sharkdp/fd/releases) and install it via:\n``` bash\nsudo dpkg -i fd_8.1.0_amd64.deb  # adapt version number and architecture\n```\n\n### On Debian\n\nIf you run Debian Buster or newer, you can install the\n[officially maintained Debian package](https://tracker.debian.org/pkg/rust-fd-find):\n```\nsudo apt-get install fd-find\n```\nNote that the binary is called `fdfind` as the binary name `fd` is already used by another package.\nIt is recommended that you add an `alias fd=fdfind` to your shells initialization file, in order to\nuse `fd` in the same way as in this documentation.\n\n### On Fedora\n\nStarting with Fedora 28, you can install `fd` from the official package sources:\n``` bash\ndnf install fd-find\n```\n\nFor older versions, you can use this [Fedora copr](https://copr.fedorainfracloud.org/coprs/keefle/fd/) to install `fd`:\n``` bash\ndnf copr enable keefle/fd\ndnf install fd\n```\n\n### On Alpine Linux\n\nYou can install [the fd package](https://pkgs.alpinelinux.org/packages?name=fd)\nfrom the official sources, provided you have the appropriate repository enabled:\n```\napk add fd\n```\n\n### On Arch Linux\n\nYou can install [the fd package](https://www.archlinux.org/packages/community/x86_64/fd/) from the official repos:\n```\npacman -S fd\n```\n### On Gentoo Linux\n\nYou can use [the fd ebuild](https://packages.gentoo.org/packages/sys-apps/fd) from the official repo:\n```\nemerge -av fd\n```\n\n### On openSUSE Linux\n\nYou can install [the fd package](https://software.opensuse.org/package/fd) from the official repo:\n```\nzypper in fd\n```\n\n### On Void Linux\n\nYou can install `fd` via xbps-install:\n```\nxbps-install -S fd\n```\n\n### On macOS\n\nYou can install `fd` with [Homebrew](https://formulae.brew.sh/formula/fd):\n```\nbrew install fd\n```\n\n\u2026 or with MacPorts:\n```\nsudo port install fd\n```\n\n### On Windows\n\nYou can download pre-built binaries from the [release page](https://github.com/sharkdp/fd/releases).\n\nAlternatively, you can install `fd` via [Scoop](http://scoop.sh):\n```\nscoop install fd\n```\n\nOr via [Chocolatey](https://chocolatey.org):\n```\nchoco install fd\n```\n\n### On NixOS / via Nix\n\nYou can use the [Nix package manager](https://nixos.org/nix/) to install `fd`:\n```\nnix-env -i fd\n```\n\n### On FreeBSD\n\nYou can install [the fd-find package](https://www.freshports.org/sysutils/fd) from the official repo:\n```\npkg install fd-find\n```\n\n### From NPM\n\nOn linux and macOS, you can install the [fd-find](https://npm.im/fd-find) package:\n\n```\nnpm install -g fd-find\n```\n\n### From source\n\nWith Rust's package manager [cargo](https://github.com/rust-lang/cargo), you can install *fd* via:\n```\ncargo install fd-find\n```\nNote that rust version *1.36.0* or later is required.\n\n### From binaries\n\nThe [release page](https://github.com/sharkdp/fd/releases) includes precompiled binaries for Linux, macOS and Windows.\n\n## Development\n```bash\ngit clone https://github.com/sharkdp/fd\n\n# Build\ncd fd\ncargo build\n\n# Run unit tests and integration tests\ncargo test\n\n# Install\ncargo install\n```\n\n## Command-line options\n```\nUSAGE:\n    fd [FLAGS/OPTIONS] [<pattern>] [<path>...]\n\nFLAGS:\n    -H, --hidden            Search hidden files and directories\n    -I, --no-ignore         Do not respect .(git|fd)ignore files\n    -s, --case-sensitive    Case-sensitive search (default: smart case)\n    -i, --ignore-case       Case-insensitive search (default: smart case)\n    -g, --glob              Glob-based search (default: regular expression)\n    -a, --absolute-path     Show absolute instead of relative paths\n    -l, --list-details      Use a long listing format with file metadata\n    -L, --follow            Follow symbolic links\n    -p, --full-path         Search full path (default: file-/dirname only)\n    -0, --print0            Separate results by the null character\n    -h, --help              Prints help information\n    -V, --version           Prints version information\n\nOPTIONS:\n    -d, --max-depth <depth>            Set maximum search depth (default: none)\n    -t, --type <filetype>...           Filter by type: file (f), directory (d), symlink (l),\n                                       executable (x), empty (e), socket (s), pipe (p)\n    -e, --extension <ext>...           Filter by file extension\n    -x, --exec <cmd>                   Execute a command for each search result\n    -X, --exec-batch <cmd>             Execute a command with all search results at once\n    -E, --exclude <pattern>...         Exclude entries that match the given glob pattern\n    -c, --color <when>                 When to use colors: never, *auto*, always\n    -S, --size <size>...               Limit results based on the size of files.\n        --changed-within <date|dur>    Filter by file modification time (newer than)\n        --changed-before <date|dur>    Filter by file modification time (older than)\n\nARGS:\n    <pattern>    the search pattern - a regular expression unless '--glob' is used (optional)\n    <path>...    the root directory for the filesystem search (optional)\n```\n\nThis is the output of `fd -h`. To see the full set of command-line options, use `fd --help` which\nalso includes a much more detailed help text.\n\n## Tutorial\n\nFirst, to get an overview of all available command line options, you can either run\n`fd -h` for a concise help message (see above) or `fd --help` for a more detailed\nversion.\n\n### Simple search\n\n*fd* is designed to find entries in your filesystem. The most basic search you can perform is to\nrun *fd* with a single argument: the search pattern. For example, assume that you want to find an\nold script of yours (the name included `netflix`):\n``` bash\n> fd netfl\nSoftware/python/imdb-ratings/netflix-details.py\n```\nIf called with just a single argument like this, *fd* searches the current directory recursively\nfor any entries that *contain* the pattern `netfl`.\n\n### Regular expression search\n\nThe search pattern is treated as a regular expression. Here, we search for entries that start\nwith `x` and end with `rc`:\n``` bash\n> cd /etc\n> fd '^x.*rc$'\nX11/xinit/xinitrc\nX11/xinit/xserverrc\n```\n\n### Specifying the root directory\n\nIf we want to search a specific directory, it can be given as a second argument to *fd*:\n``` bash\n> fd passwd /etc\n/etc/default/passwd\n/etc/pam.d/passwd\n/etc/passwd\n```\n\n### Running *fd* without any arguments\n\n*fd* can be called with no arguments. This is very useful to get a quick overview of all entries\nin the current directory, recursively (similar to `ls -R`):\n``` bash\n> cd fd/tests\n> fd\ntestenv\ntestenv/mod.rs\ntests.rs\n```\n\nIf you want to use this functionality to list all files in a given directory, you have to use\na catch-all pattern such as `.` or `^`:\n``` bash\n> fd . fd/tests/\ntestenv\ntestenv/mod.rs\ntests.rs\n```\n\n### Searching for a particular file extension\n\nOften, we are interested in all files of a particular type. This can be done with the `-e` (or\n`--extension`) option. Here, we search for all Markdown files in the fd repository:\n``` bash\n> cd fd\n> fd -e md\nCONTRIBUTING.md\nREADME.md\n```\n\nThe `-e` option can be used in combination with a search pattern:\n``` bash\n> fd -e rs mod\nsrc/fshelper/mod.rs\nsrc/lscolors/mod.rs\ntests/testenv/mod.rs\n```\n\n### Hidden and ignored files\nBy default, *fd* does not search hidden directories and does not show hidden files in the\nsearch results. To disable this behavior, we can use the `-H` (or `--hidden`) option:\n``` bash\n> fd pre-commit\n> fd -H pre-commit\n.git/hooks/pre-commit.sample\n```\n\nIf we work in a directory that is a Git repository (or includes Git repositories), *fd* does not\nsearch folders (and does not show files) that match one of the `.gitignore` patterns. To disable\nthis behavior, we can use the `-I` (or `--no-ignore`) option:\n``` bash\n> fd num_cpu\n> fd -I num_cpu\ntarget/debug/deps/libnum_cpus-f5ce7ef99006aa05.rlib\n```\n\nTo really search *all* files and directories, simply combine the hidden and ignore features to show\neverything (`-HI`).\n\n### Excluding specific files or directories\n\nSometimes we want to ignore search results from a specific subdirectory. For example, we might\nwant to search all hidden files and directories (`-H`) but exclude all matches from `.git`\ndirectories. We can use the `-E` (or `--exclude`) option for this. It takes an arbitrary glob\npattern as an argument:\n``` bash\n> fd -H -E .git \u2026\n```\n\nWe can also use this to skip mounted directories:\n``` bash\n> fd -E /mnt/external-drive \u2026\n```\n\n.. or to skip certain file types:\n``` bash\n> fd -E '*.bak' \u2026\n```\n\nTo make exclude-patterns like these permanent, you can create a `.fdignore` file. They work like\n`.gitignore` files, but are specific to `fd`. For example:\n``` bash\n> cat ~/.fdignore\n/mnt/external-drive\n*.bak\n```\nNote: `fd` also supports `.ignore` files that are used by other programs such as `rg` or `ag`.\n\nIf you want `fd` to ignore these patterns globally, you can put them in `fd`'s global ignore file.\nThis is usually located in `~/.config/fd/ignore` in macOS or Linux, and `%APPDATA%\\fd\\ignore` in\nWindows.\n\n### Using fd with `xargs` or `parallel`\n\nIf we want to run a command on all search results, we can pipe the output to `xargs`:\n``` bash\n> fd -0 -e rs | xargs -0 wc -l\n```\nHere, the `-0` option tells *fd* to separate search results by the NULL character (instead of\nnewlines). In the same way, the `-0` option of `xargs` tells it to read the input in this way.\n\n### Deleting files\n\nYou can use `fd` to remove all files and directories that are matched by your search pattern.\nIf you only want to remove files, you can use the `--exec-batch`/`-X` option to call `rm`. For\nexample, to recursively remove all `.DS_Store` files, run:\n``` bash\n> fd -H '^\\.DS_Store$' -tf -X rm\n```\nIf you are unsure, always call `fd` without `-X rm` first. Alternatively, use `rm`s \"interactive\"\noption:\n``` bash\n> fd -H '^\\.DS_Store$' -tf -X rm -i\n```\n\nIf you also want to remove a certain class of directories, you can use the same technique. You will\nhave to use `rm`s `--recursive`/`-r` flag to remove directories.\n\nNote: there are scenarios where using `fd \u2026 -X rm -r` can cause race conditions: if you have a\npath like `\u2026/foo/bar/foo/\u2026` and want to remove all directories named `foo`, you can end up in a\nsituation where the outer `foo` directory is removed first, leading to (harmless) *\"'foo/bar/foo':\nNo such file or directory\"* errors in the `rm` call.\n\n### Troubleshooting\n\n#### `fd` does not find my file!\n\nRemember that `fd` ignores hidden directories and files by default. It also ignores patterns\nfrom `.gitignore` files. If you want to make sure to find absolutely every possible file, always\nuse the options `-H` and `-I` to disable these two features:\n``` bash\n> fd -HI \u2026\n```\n\n#### `fd` doesn't seem to interpret my regex pattern correctly\n\nA lot of special regex characters (like `[]`, `^`, `$`, ..) are also special characters in your\nshell. If in doubt, always make sure to put single quotes around the regex pattern:\n\n``` bash\n> fd '^[A-Z][0-9]+$'\n```\n\nIf your pattern starts with a dash, you have to add `--` to signal the end of command line\noptions. Otherwise, the pattern will be interpreted as a command-line option. Alternatively,\nuse a character class with a single hyphen character:\n\n``` bash\n> fd -- '-pattern'\n> fd '[-]pattern'\n```\n\n### Integration with other programs\n\n#### Using fd with `fzf`\n\nYou can use *fd* to generate input for the command-line fuzzy finder [fzf](https://github.com/junegunn/fzf):\n``` bash\nexport FZF_DEFAULT_COMMAND='fd --type file'\nexport FZF_CTRL_T_COMMAND=\"$FZF_DEFAULT_COMMAND\"\n```\n\nThen, you can type `vim <Ctrl-T>` on your terminal to open fzf and search through the fd-results.\n\nAlternatively, you might like to follow symbolic links and include hidden files (but exclude `.git` folders):\n``` bash\nexport FZF_DEFAULT_COMMAND='fd --type file --follow --hidden --exclude .git'\n```\n\nYou can even use fd's colored output inside fzf by setting:\n``` bash\nexport FZF_DEFAULT_COMMAND=\"fd --type file --color=always\"\nexport FZF_DEFAULT_OPTS=\"--ansi\"\n```\n\nFor more details, see the [Tips section](https://github.com/junegunn/fzf#tips) of the fzf README.\n\n#### Using fd with `emacs`\n\nThe emacs package [find-file-in-project](https://github.com/technomancy/find-file-in-project) can\nuse *fd* to find files.\n\nAfter installing `find-file-in-project`, add the line `(setq ffip-use-rust-fd t)` to your\n`~/.emacs` or `~/.emacs.d/init.el` file.\n\nIn emacs, run `M-x find-file-in-project-by-selected` to find matching files. Alternatively, run\n`M-x find-file-in-project` to list all available files in the project.\n\n#### Printing fd's output as a tree\n\nTo format the output of `fd` similar to the `tree` command, install [`as-tree`] and pipe the output\nof `fd` to `as-tree`:\n```bash\nfd | as-tree\n```\n\nThis can be more useful than running `tree` by itself because `tree` does not ignore any files by\ndefault, nor does it support as rich a set of options as `fd` does to control what to print:\n```bash\n\u276f fd --extension rs | as-tree\n.\n\u251c\u2500\u2500 build.rs\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 app.rs\n    \u2514\u2500\u2500 error.rs\n```\n\nFor more information about `as-tree`, see [the `as-tree` README][`as-tree`].\n\n[`as-tree`]: https://github.com/jez/as-tree\n\n## Maintainers\n\n- [sharkdp](https://github.com/sharkdp)\n- [tmccombs](https://github.com/tmccombs)\n\n## License\nCopyright (c) 2017-2020 The fd developers\n\n`fd` is distributed under the terms of both the MIT License and the Apache License 2.0.\n\nSee the [LICENSE-APACHE](LICENSE-APACHE) and [LICENSE-MIT](LICENSE-MIT) files for license details.\n"