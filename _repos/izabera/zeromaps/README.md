"A \"living\" Linux process with no memory\n=======================================\n\n\n\ntl;dr\n----\n\n- thread1 goes into uninterruptible sleep\n- thread2 unmaps everything and segfaults\n- segv can't kill the process because of thread1's D state\n- /proc/pid/maps is now empty\n- ???\n- PROFIT!!!\n\n\n\n[![asciicast](https://asciinema.org/a/313677.svg)](https://asciinema.org/a/313677)\n\n\n\nImplementation details\n----------------------\n\nThis code gets a list of all memory maps from `/proc/self/maps`, then creates a\nnew executable map where it jits some code that calls `munmap()` on each of the\nmaps it just got, and finally on the map it's on.  This is just a quick example\nwith no portability in mind, so the source code contains the actual bytes that\nwould be emitted by a x64 compiler.  After unmapping the final map, where the\njit code lies, there's no new instruction to execute and a segfault is raised.\n\nThis segfault can't kill the entire process if one thread is stuck in\nuninterruptible sleep.  To reliably send a thread in such state, we create a\nsimple FUSE filesystem in python, in which doing anything on a particular file\nwill block until a key is pressed.\n\nThis code also does its own \"linking\" to make sure that the list of maps\ndoesn't get unmapped too early.\n\n\nRequirements\n------------\n\n- a c compiler\n- python2 + fuse\n- x64\n- a modern Linux with no vsyscall page (this page is too high up and munmap\n  would return EINVAL)\n\n\n\nWhy\n---\n\nI don't know.  I thought it was funny.\n"