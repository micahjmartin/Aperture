"# protobuf-inspector\n\nSimple program that can parse [Google Protobuf][] encoded blobs\n(version 2 or 3) without knowing their accompanying definition.\nIt will print a nice, colored representation of their contents. Example:\n\n![Main screenshot](https://i.imgur.com/Vw403MI.png)\n\nAs you can see, the field names are obviously lost, together with\nsome high-level details such as:\n\n - whether a varint uses [zig-zag encoding][] or not (will assume no zig-zag by default)\n - whether a 32-bit/64-bit value is an integer or float (both shown by default)\n - signedness (auto-detect by default)\n\nBut protobuf-inspector is able to correctly guess the message structure\nmost of the time. When it finds embedded binary data on a field, it'll\nfirst try to parse it as a message. If that fails, it'll display the data\nas a string or hexdump. It can make mistakes, especially with small chunks.\n\nIt shows the fields just in the order they are encoded in the\nwire, so it can be useful for those wanting to get familiar with\nthe [wire format][] or parser developers, in addition to reverse-engineering.\n\n## Usage\n\nNo dependencies required. Just run `main.py` and feed the protobuf blob\non stdin:\n\n    ./main.py < my-protobuf-blob\n\nAfter reading the first (blind) analysis of the blob, you typically start defining\nsome of the fields so protobuf-inspector can better parse your blobs, until you get\nto a point where you have a full protobuf definition and the parser no longer has\nto guess anything.\n\n[Read about defining fields here.](CONFIG.md)\n\n## Parsing errors\n\nIf a parsing error is found, parsing will stop *within that field*, but\nwill go on unaffected at the outside of the hierarchy. The stack trace will\nbe printed where the field contents would go, along with a hexdump indicating where\nparsing was stopped in that chunk, if applicable.\n\nSo, if you specified a `uint32` and a larger varint is found, you'd get something like:\n\n![Error on invalid varint](https://i.imgur.com/DWG9MGX.png)\n\nIf you specified that some field contained an embedded message, but invalid data was\nfound there, you'd get:\n\n![Error on invalid message](https://i.imgur.com/URaWqXz.png)\n\nPlease note that `main.py` will exit with non-zero status if one or more parsing\nerrors occurred.\n\n## Tricks\n\nThere are some tricks you can use to save time when approaching a blob:\n\n 1. If you are positive that a varint does *not* use zig-zag encoding, but are still\n    not sure of the signedness, leave it as `varint`. If it does use zig-zag encoding,\n    use `sint64` unless you are sure it's 32-bit and not 64-bit.\n\n 2. If a chunk is wrongly being recognized as a `packed chunk` or an embedded message,\n    or if you see something weird with the parsed message and want to see the raw bytes,\n    specify a type of `bytes`. Conversely, if for some reason it's not being detected\n    as an embedded message and it should, force it to `message` to see the reason.\n\n 3. If you want to extract a chunk's raw data to a file to analyze it better, specify a\n    type of `dump` and protobuf-inspector will create `dump.0`, `dump.1`,\n    etc. every time it finds a matching blob.\n\n 4. protobuf-inspector parses the blob as a message of type `root`, but that's just a\n    default. If you have lots of message types defined, you can pass a type name as\n    optional argument, and protobuf-inspector will use that instead of `root`:\n    \n        ./main.py request < my-protobuf-blob\n\n\n\n[Google Protobuf]: https://developers.google.com/protocol-buffers\n[Wire format]: https://developers.google.com/protocol-buffers/docs/encoding\n[Zig-zag encoding]: https://developers.google.com/protocol-buffers/docs/encoding#signed-integers\n"