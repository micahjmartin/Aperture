"# Geneva [![Build Status](https://travis-ci.com/Kkevsterrr/geneva.svg?branch=master)](https://travis-ci.com/Kkevsterrr/geneva) [![codecov](https://codecov.io/gh/Kkevsterrr/geneva/branch/master/graph/badge.svg)](https://codecov.io/gh/Kkevsterrr/geneva) [![Documentation Status](https://readthedocs.org/projects/geneva/badge/?version=latest)](https://geneva.readthedocs.io/en/latest/?badge=latest)\n\nGeneva is an artificial intelligence tool that defeats censorship by exploiting bugs in censors, such as those in China, India, and Kazakhstan. Unlike many other anti-censorship solutions which require assistance from outside the censoring regime (Tor, VPNs, etc.), Geneva runs strictly on one side of the connection (either the client or server side).\n\nUnder the hood, Geneva uses a genetic algorithm to evolve censorship evasion strategies and has found several previously unknown bugs in censors. Geneva's strategies manipulate the network stream to confuse the censor without impacting the client/server communication. This makes Geneva effective against many types of in-network censorship (though it cannot be used against IP-blocking censorship). \n\nGeneva is composed of two high level components: its genetic algorithm (which it uses to evolve new censorship evasion strategies) and its strategy engine (which is uses to run an individual censorship evasion strategy over a network connection). \n\nThis codebase contains the Geneva's full implementation: its genetic algorithm, strategy engine, Python API, and a subset of published strategies. With these tools, users and researchers alike can evolve new strategies or leverage existing strategies to evade censorship. To learn more about how Geneva works, see [How it Works](#How-it-Works) or checkout our [documentation](https://geneva.readthedocs.io). \n\n## Setup\n\nGeneva has been developed and tested for Centos or Debian-based systems. Due to limitations of\nnetfilter and raw sockets, Geneva does not work on OS X or Windows at this time and requires *python3.6*.\nMore detailed setup instructions are available at our [documentation](https://geneva.readthedocs.io).\n\nInstall netfilterqueue dependencies:\n```\n# sudo apt-get install build-essential python-dev libnetfilter-queue-dev libffi-dev libssl-dev iptables python3-pip\n```\n\nInstall Python dependencies:\n```\n# python3 -m pip install -r requirements.txt\n```\n\n## Running a Strategy\n\nA censorship evasion strategy is simply a _description of how network traffic should be modified_. A strategy is not\ncode, it is a description that tells the engine how it should operate over traffic. For a fuller description of the DNA syntax, see [Censorship Evasion Strategies](#Censorship-Evasion-Strategies).\n\n```\n# python3 engine.py --server-port 80 --strategy \"[TCP:flags:PA]-duplicate(tamper{TCP:dataofs:replace:10}(tamper{TCP:chksum:corrupt},),)-|\" --log debug\n2019-10-14 16:34:45 DEBUG:[ENGINE] Engine created with strategy \\/ (ID bm3kdw3r) to port 80\n2019-10-14 16:34:45 DEBUG:[ENGINE] Configuring iptables rules\n2019-10-14 16:34:45 DEBUG:[ENGINE] iptables -A OUTPUT -p tcp --sport 80 -j NFQUEUE --queue-num 1\n2019-10-14 16:34:45 DEBUG:[ENGINE] iptables -A INPUT -p tcp --dport 80 -j NFQUEUE --queue-num 2\n2019-10-14 16:34:45 DEBUG:[ENGINE] iptables -A OUTPUT -p udp --sport 80 -j NFQUEUE --queue-num 1\n2019-10-14 16:34:45 DEBUG:[ENGINE] iptables -A INPUT -p udp --dport 80 -j NFQUEUE --queue-num 2\n```\n\nNote that if you have stale `iptables` rules or other rules that rely on Geneva's default queues,\nthis will fail. To fix this, remove those rules. \n\n## Strategy Library\n\nGeneva has found dozens of strategies that work against censors in China, Kazakhstan, India, and Iran. We include several of these strategies in [strategies.md](strategies.md). Note that this file contains success rates for each individual country; a strategy that works in one country may not work as well as other countries.\n\nResearchers have observed that strategies may have differing success rates based on your exact location. Although we have not observed this from our vantage points, you may find that some strategies may work differently in a country we have tested. If this is the case, don't be alarmed. However, please feel free to reach out to a member of the team directly or open an issue on this page so we can track how the strategies work from other geographic locations.\n\n## Disclaimer\n\nRunning these strategies may place you at risk if you use it within a censoring regime. Geneva takes overt actions that interfere with the normal operations of a censor and its strategies are detectable on the network. During the training process, Geneva will intentionally trip censorship many times. Geneva is not an anonymity tool, nor does it encrypt any traffic. Understand the risks of running Geneva in your country before trying it.\n\n-------\n\n# How it Works\n\nSee our [paper](#Paper) for an in-depth read on how Geneva works. Below is a walkthrough of the main concepts behind Geneva, the major components of the codebase, and how they can be used. \n\n## Censorship Evasion Strategies\n\nA censorship evasion strategy is simply a _description of how network traffic should be modified_. A strategy is _not\ncode_, it is a description that tells Geneva's stratgy engine how it should manipulate network traffic. The goal of a censorship evasion strategy is to modify the network traffic in a such a way that the censor is unable to censor it, but the client/server communication is unimpacted.  \n\nA censorship evasion strategy composed of one or more packet-level building blocks. Geneva's core building blocks are:\n1. `duplicate`: takes one packet and returns two copies of the packet\n2. `drop`: takes one packet and returns no packets (drops the packet)\n3. `tamper`: takes one packet and returns the modified packet\n4. `fragment`: takes one packet and returns two fragments or two segments\n\nSince `duplicate` and `fragment` introduce _branching_, these actions are composed into a binary-tree structure called an _action tree_. Each tree also has a _trigger_. The trigger describes which packets the tree should run on, and the tree describes what should happen to each of those packets when the trigger fires. Once a trigger fires on a packet, it pulls the packet into the tree for modifications, and the packets that emerge from the tree are sent on the wire. Recall that Geneva operates at the packet level, therefore all triggers are packet-level triggers. \n\nMultiple action trees together form a _forest_. Geneva handles outbound and inbound packets differently, so strategies are composed of two forests: an outbound forest and an inbound forest.\n\nConsider the following example of a simple Geneva strategy. \n```       \n                   +---------------+\n                   |  TCP:flags:A  |         <-- triggers on TCP packets with the flags field set to 'ACK'\n                   +-------+-------+             matching packets are captured and pulled into the tree\n                           |\n                 +---------v---------+\n                       duplicate             <-- makes two copies of the given packet. the tree is processed \n                 +---------+---------+           with an inorder traversal, so the left side is run first\n                           |\n             +-------------+------------+\n             |                          |\n+------------v----------+               v    <-- dupilcate has no right child, so this packet will be sent on the wire unimpacted\n          tamper              \n  {TCP:flags:replace:R}      <-- parameters to this action describe how the packet should be tampered \n+------------+----------+\n             |\n+------------v----------+\n          tamper\n   {TCP:chksum:corrupt}\n+------------+----------+\n             |\n             v               <-- packets that emerge from an in-order traversal of the leaves are sent on the wire\n\n```\n\nThis strategy triggers on `TCP` packets with the `flags` field set to `ACK`. It makes a duplicate of the `ACK` packet; the first duplicate has its flags field changed to `RST` and its checksum (`chksum`) field corrupted; the second duplicate is unchaged. Both packets are then sent on the network. \n\n### Strategy DNA\n\nThese strategies can be arbitrarily complicated, and Geneva defines a well-formatted string syntax for\nunambiguously expressing strategies.\n\nA strategy divides how it handles outbound and inbound packets: these are separated in the DNA by a \n\"\\\\/\". Specifically, the strategy format is `<outbound forest> \\/ <inbound forest>`. If `\\/` is not\npresent in a strategy, all of the action trees are in the outbound forest. \n\nBoth forests are composed of action trees, and each forest is allowed an arbitrarily many trees. \n\nAction trees always start with a trigger, which is formatted as: `[<protocol>:<field>:<value>]`. For example, the trigger: `[TCP:flags:S]` will run its corresponding tree whenever it sees a `TCP` packet with the `flags` field set to `SYN`. If the corresponding action tree is `[TCP:flags:S]-drop-|`, this action tree will cause the engine to drop any `SYN` packets. `[TCP:flags:S]-duplicate-|` will cause the engine to duplicate any SYN packets. \n\nSyntactically, action trees end with `-|`.\n\nDepending on the type of action, some actions can have up to two children (such as `duplicate`). These are represented\nwith the following syntax: `[TCP:flags:S]-duplicate(<left_child>,<right_child>)-|`, where\n`<left_child>` and `<right_child>` themselves are trees. If `(,)` is not specified, any packets\nthat emerge from the action will be sent on the wire. If an action only has one child (such as `tamper`), it is always the left child. `[TCP:flags:S]-tamper{<parameters>}(<left_child>,)-|`\n\nActions that have parameters specify those parameters within `{}`. For example, giving parameters to the `tamper` action could look like: `[TCP:flags:S]-tamper{TCP:flags:replace:A}-|`. This strategy would trigger on TCP `SYN` packets and replace the TCP `flags` field to `ACK`. \n\nPutting this all together, below is the strategy DNA representation of the above diagram:\n```\n[TCP:flags:A]-duplicate(tamper{TCP:flags:replace:R}(tamper{TCP:chksum:corrupt},),)-| \\/\n```\n\nGeneva has code to parse this strategy DNA into strategies that can be applied to network traffic using the engine. \n\nNote that due to limitations of Scapy and NFQueue, actions that introduce branching (`fragment`, `duplicate`) are\ndisabled for incoming action forests. \n\n## Engine\n\nThe strategy engine (`engine.py`) applies a strategy to a network connection. The engine works by capturing all traffic to/from a specified port. Packets that match an active trigger are run through the associated action-tree, and packets that emerge from the tree are sent on the wire. \n\nThe engine also has a Python API for using it in your application. It can be used as a context manager or invoked in the background as a thread. \nFor example, consider the following simple application. \n\n```python\nimport os\nimport engine\n\n# Port to run the engine on\nport = 80\n# Strategy to use\nstrategy = \"[TCP:flags:A]-duplicate(tamper{TCP:flags:replace:R}(tamper{TCP:chksum:corrupt},),)-| \\/\"\n\n# Create the engine in debug mode\nwith engine.Engine(port, strategy, log_level=\"debug\") as eng:\n    os.system(\"curl http://example.com?q=ultrasurf\")\n```\nThis script creates an instance of the engine with a specified strategy, and that strategy will be running for everything within the context manager. When the context manager exits, the engine will clean itself up. See the `examples/` folder for more use cases of the engine. \n\nDue to limitations of scapy and NFQueue, the engine cannot be used to communicate with localhost.\n\n## Citation\n\nIf you like the work or plan to use it in your projects, please follow the guidelines in [citation.bib](https://github.com/Kkevsterrr/geneva/blob/master/citation.bib).\n\n## Paper\n\nSee [our paper](http://geneva.cs.umd.edu/papers/geneva_ccs19.pdf) from CCS or the rest of [our papers and talks](http://geneva.cs.umd.edu/papers/) for an in-depth dive into how Geneva works and how it can be applied.\n\n## Contributors\n\n[Kevin Bock](https://github.com/Kkevsterrr)\n\n[George Hughey](https://github.com/ecthros)\n\n[Xiao Qiang](https://twitter.com/rockngo)\n\n[Dave Levin](https://www.cs.umd.edu/~dml/)\n"