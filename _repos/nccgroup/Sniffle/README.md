"# Sniffle\n\n**Sniffle is a sniffer for Bluetooth 5 and 4.x (LE) using TI CC1352/CC26x2 hardware.**\n\nSniffle has a number of useful features, including:\n\n* Support for BT5/4.2 extended length advertisement and data packets\n* Support for BT5 Channel Selection Algorithms #1 and #2\n* Support for all BT5 PHY modes (regular 1M, 2M, and coded modes)\n* Support for sniffing only advertisements and ignoring connections\n* Support for channel map, connection parameter, and PHY change operations\n* Support for advertisement filtering by MAC address and RSSI\n* Support for BT5 extended advertising (non-periodic)\n* Support for capturing advertisements from a target MAC on all three primary\n  advertising channels using a single sniffer. **This makes connection detection\n  nearly 3x more reliable than most other sniffers that only sniff one advertising\n  channel.**\n* Easy to extend host-side software written in Python\n* PCAP export compatible with the Ubertooth\n\n## Prerequisites\n\n* TI CC26x2R Launchpad Board: <https://www.ti.com/tool/LAUNCHXL-CC26X2R1>\n* or TI CC2652RB Launchpad Board: <https://www.ti.com/tool/LP-CC2652RB>\n* or TI CC1352R Launchpad Board: <https://www.ti.com/tool/LAUNCHXL-CC1352R1>\n* GNU ARM Embedded Toolchain: <https://developer.arm.com/open-source/gnu-toolchain/gnu-rm/downloads>\n* TI CC26x2 SDK 4.10.00.78: <https://www.ti.com/tool/download/SIMPLELINK-CC13X2-26X2-SDK>\n* TI SysConfig 1.4.0\\_1234: <https://www.ti.com/tool/download/SYSCONFIG>\n* TI DSLite Programmer Software: see below\n* Python 3.5+ with PySerial installed\n\n**If you don't want to go through the effort of setting up a build\nenvironment for the firmware, you can just flash prebuilt firmware binaries\nusing UniFlash/DSLite.** Prebuilt firmware binaries are attached to releases\non the GitHub releases tab of this project. When using prebuilt firmware, be\nsure to use the Python code corresponding to the release tag rather than master\nto avoid compatibility issues with firmware that is behind the master branch.\n\nNote: it should be possible to compile Sniffle to run on CC1352P Launchpad\nboards with minimal modifications, but I have not yet tried this.\n\n### Installing GCC\n\nThe `arm-none-eabi-gcc` provided through various Linux distributions' package\nmanager often lacks some header files or requires some changes to linker\nconfiguration. For minimal hassle, I suggest using the ARM GCC linked above.\nYou can just download and extract the prebuilt executables.\n\n### Installing the TI SDK\n\nThe TI SDK is provided as an executable binary that extracts a bunch of source\ncode once you accept the license agreement. On Linux and Mac, the default\ninstallation directory is inside`~/ti/`. This works fine and my makefiles\nexpect this path, so I suggest just going with the default here. The same\napplies for the TI SysConfig tool.\n\nOnce the SDK has been extracted, you will need to edit one makefile to match\nyour build environment. Within `~/ti/simplelink_cc13x2_26x2_sdk_4_10_00_78`\n(or wherever the SDK was installed) there is a makefile named `imports.mak`.\nThe only paths that need to be set here to build Sniffle are for GCC, XDC, and\nSysConfig. We don't need the CCS compiler. See the diff below as an example,\nand adapt for wherever you installed things.\n\n```\ndiff --git a/imports.mak b/imports.mak\nindex 5a8fb0cb..e99a03e7 100644\n--- a/imports.mak\n+++ b/imports.mak\n@@ -18,12 +18,12 @@\n # will build using each non-empty *_ARMCOMPILER cgtool.\n #\n \n-XDC_INSTALL_DIR        ?= /home/username/ti/xdctools_3_61_00_16_core\n-SYSCONFIG_TOOL         ?= /home/username/ti/ccs1000/ccs/utils/sysconfig_1.4.0/sysconfig_cli.sh\n+XDC_INSTALL_DIR        ?= $(HOME)/ti/xdctools_3_61_00_16_core\n+SYSCONFIG_TOOL         ?= $(HOME)/ti/sysconfig_1.4.0/sysconfig_cli.sh\n \n \n-CCS_ARMCOMPILER        ?= /home/username/ti/ccs1000/ccs/tools/compiler/ti-cgt-arm_20.2.0.LTS\n-GCC_ARMCOMPILER        ?= /home/username/ti/ccs1000/ccs/tools/compiler/gcc-arm-none-eabi-9-2019-q4-major\n+CCS_ARMCOMPILER        ?= $(HOME)/ti/ccs1000/ccs/tools/compiler/ti-cgt-arm_20.2.0.LTS\n+GCC_ARMCOMPILER        ?= $(HOME)/arm_tools/gcc-arm-none-eabi-9-2019-q4-major\n \n # The IAR compiler is not supported on Linux\n # IAR_ARMCOMPILER      ?=\n```\n\n### Obtaining DSLite\n\nDSLite is TI's command line programming and debug server tool for XDS110\ndebuggers. The CC26xx and CC13xx Launchpad boards both include XDS110 debuggers.\nUnfortunately, TI does not provide a standalone command line DSLite download.\nThe easiest way to obtain DSLite is to install [UniFlash](http://www.ti.com/tool/download/UNIFLASH)\nfrom TI. It's available for Linux, Mac, and Windows. The DSLite executable will\nbe located at `deskdb/content/TICloudAgent/linux/ccs_base/DebugServer/bin/DSLite`\nrelative to the UniFlash installation directory. On Linux, the default UniFlash\ninstallation directory is inside `~/ti/`.\n\nYou should place the DSLite executable directory within your `$PATH`.\n\n## Building and Installation\n\nOnce the GCC, DSLite, and the SDK is installed and operational, building\nSniffle should be straight forward. Just navigate to the `fw` directory and\nrun `make`. If you didn't install the SDK to the default directory, you may\nneed to edit `SIMPLELINK_SDK_INSTALL_DIR` in the makefile.\n\nTo install Sniffle on a (plugged in) CC26x2 Launchpad using DSLite, run\n`make load` within the `fw` directory. You can also flash the compiled\n`sniffle.out` binary using the UniFlash GUI.\n\nIf building for or installing on a CC1352R Launchpad instead of a CC26x2R,\nyou must specify `PLATFORM=CC1352R1F3`, either as an argument to make, or\nby defining it as an environment variable prior to invoking make. Similarly,\nspecify `PLATFORM=CC2652RB1F` when building for CC2652RB Launchpad instead of\nthe regular CC26x2R version. Be sure to perform a `make clean` before building\nfor a different platform.\n\n## Sniffer Usage\n\n```\n[skhan@serpent python_cli]$ ./sniff_receiver.py --help\nusage: sniff_receiver.py [-h] [-s SERPORT] [-c {37,38,39}] [-p] [-r RSSI]\n                         [-m MAC] [-a] [-e] [-H] [-l] [-o OUTPUT]\n\nHost-side receiver for Sniffle BLE5 sniffer\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -s SERPORT, --serport SERPORT\n                        Sniffer serial port name\n  -c {37,38,39}, --advchan {37,38,39}\n                        Advertising channel to listen on\n  -p, --pause           Pause sniffer after disconnect\n  -r RSSI, --rssi RSSI  Filter packets by minimum RSSI\n  -m MAC, --mac MAC     Filter packets by advertiser MAC\n  -i IRK, --irk IRK     Filter packets by advertiser IRK\n  -a, --advonly         Sniff only advertisements, don't follow connections\n  -e, --extadv          Capture BT5 extended (auxiliary) advertising\n  -H, --hop             Hop primary advertising channels in extended mode\n  -l, --longrange       Use long range (coded) PHY for primary advertising\n  -o OUTPUT, --output OUTPUT\n                        PCAP output file name\n```\n\nThe XDS110 debugger on the Launchpad boards creates two serial ports. On\nLinux, they are typically named `ttyACM0` and `ttyACM1`. The first of the\ntwo created serial ports is used to communicate with Sniffle. By default,\nthe Python CLI communicates using `/dev/ttyACM0`, but you may need to\noverride this with the `-s` command line option if you are not running on\nLinux or have additional USB CDC-ACM devices connected.\n\nFor the `-r` (RSSI filter) option, a value of -40 tends to work well if the\nsniffer is very close to or nearly touching the transmitting device. The RSSI\nfilter is very useful for ignoring irrelevant advertisements in a busy RF\nenvironment. The RSSI filter is only active when capturing advertisements,\nas you always want to capture data channel traffic for a connection being\nfollowed. You probably don't want to use an RSSI filter when MAC filtering\nis active, as you may lose advertisements from the MAC address of interest\nwhen the RSSI is too low.\n\nTo hop along with advertisements and have reliable connection sniffing, you\nneed to set up a MAC filter with the `-m` option. You should specify the\nMAC address of the peripheral device, not the central device. To figure out\nwhich MAC address to sniff, you can run the sniffer with RSSI filtering while\nplacing the sniffer near the target. This will show you advertisements from\nthe target device including its MAC address. It should be noted that many BLE\ndevices advertise with a randomized MAC address rather than their \"real\" fixed\nMAC written on a label.\n\nFor convenience, there is a special mode for the MAC filter by invoking the\nscript with `-m top` instead of `-m` with a MAC address. In this mode, the\nsniffer will lock onto the first advertiser MAC address it sees that passes\nthe RSSI filter. The `-m top` mode should thus always be used with an RSSI\nfilter to avoid locking onto a spurious MAC address. Once the sniffer locks\nonto a MAC address, the RSSI filter will be disabled automatically by the\nsniff receiver script (except when the `-e` option is used).\n\nMost new BLE devices use Resolvable Private Addresses (RPAs) rather than fixed\nstatic or public addresses. While you can set up a MAC filter to a particular\nRPA, devices periodically change their RPA. RPAs can can be resolved (associated\nwith a particular device) if the Identity Resolving Key (IRK) is known. Sniffle\nsupports automated RPA resolution when the IRK is provided. This avoids the need\nto keep updating the MAC filter whenever the RPA changes. You can specify an\nIRK for Sniffle with the `-i` option; the IRK should be provided in hexadecimal\nformat, with the most significant byte (MSB) first. Specifying an IRK allows\nSniffle to channel hop with an advertiser the same way it does with a MAC filter.\nThe IRK based MAC filtering feature (`-i`) is mutually exclusive with the static\nMAC filtering feature (`-m`).\n\nTo enable following auxiliary pointers in Bluetooth 5 extended advertising,\nenable the `-e` option. To improve performance and reliability in extended\nadvertising capture, this option disables hopping on the primary advertising\nchannels, even when a MAC filter is set up. If you are unsure whether a\nconnection will be established via legacy or extended advertising, you can\nenable the `-H` flag in conjunction with `-e` to perform primary channel\nhopping with legacy advertisements, and scheduled listening to extended\nadvertisement auxiliary packets. When combining `-e` and `-H`, the\nreliability of connection detection may be reduced compared to hopping on\nprimary (legacy) or secondary (extended) advertising channels alone.\n\nTo sniff the long range PHY on primary advertising channels, specify the `-l`\noption. Note that no hopping between primary advertising channels is supported\nin long range mode, since all long range advertising uses the BT5 extended\nmechanism. Under the extended mechanism, auxiliary pointers on all three\nprimary channels point to the same auxiliary packet, so hopping between\nprimary channels is unnecessary.\n\nIf for some reason the sniffer firmware locks up and refuses to capture any\ntraffic even with filters disabled, you should reset the sniffer MCU. On\nLaunchpad boards, the reset button is located beside the micro USB port.\n\n## Scanner Usage\n\n```\nsultan@sultan-neon-vm:~/sniffle/python_cli$ ./scanner.py --help\nusage: scanner.py [-h] [-s SERPORT] [-c {37,38,39}] [-r RSSI] [-e] [-l]\n\nScanner utility for Sniffle BLE5 sniffer\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -s SERPORT, --serport SERPORT\n                        Sniffer serial port name\n  -c {37,38,39}, --advchan {37,38,39}\n                        Advertising channel to listen on\n  -r RSSI, --rssi RSSI  Filter packets by minimum RSSI\n  -e, --extadv          Capture BT5 extended (auxiliary) advertising\n  -l, --longrange       Use long range (coded) PHY for primary advertising\n```\n\nThe scanner command line arguments work the same as the sniffer. The purpose of\nthe scanner utility is to passively gather a list of nearby devices advertising,\nwithout having the deluge of fast scrolling data you get with the sniffer\nutility. The hardware/firmware works exactly the same, but the scanner utility\nwill record and report observed MAC addresses only once without spamming the\ndisplay. Once you're done capturing advertisements, press Ctrl-C to stop\nscanning and report the results. The scanner will show the last advertisement\nand scan response from each target. Scan results will be sorted by RSSI in\ndescending order.\n\n## Usage Examples\n\nSniff all advertisements on channel 38, ignore RSSI < -50, stay on advertising\nchannel even when CONNECT\\_REQs are seen.\n\n```\n./sniff_receiver.py -c 38 -r -50 -a\n```\n\nSniff advertisements from MAC 12:34:56:78:9A:BC, stay on advertising channel\neven when CONNECT\\_REQs are seen, save advertisements to `data1.pcap`.\n\n```\n./sniff_receiver.py -m 12:34:56:78:9A:BC -a -o data1.pcap\n```\n\nSniff advertisements and connections for the first MAC address seen with\nRSSI >= -40. The RSSI filter will be disabled automatically once a MAC address\nhas been locked onto. Save captured data to `data2.pcap`.\n\n```\n./sniff_receiver.py -m top -r -40 -o data2.pcap\n```\n\nSniff advertisements and connections from the peripheral with big endian IRK\n4E0BEA5355866BE38EF0AC2E3F0EBC22.\n\n```\n./sniff_receiver.py -i 4E0BEA5355866BE38EF0AC2E3F0EBC22\n```\n\nSniff BT5 extended advertisements and connections from nearby (RSSI >= -55) devices.\n\n```\n./sniff_receiver.py -r -55 -e\n```\n\nSniff legacy and extended advertisements and connections from the device with the\nspecified MAC address. Save captured data to `data3.pcap`.\n\n```\n./sniff_receiver.py -eH -m 12:34:56:78:9A:BC -o data3.pcap\n```\n\nSniff extended advertisements and connections using the long range primary PHY on\nchannel 38.\n\n```\n./sniff_receiver.py -le -c 38\n```\n\nPassively scan on channel 39 for advertisements with RSSI greater than -50, and\nenable capture of extended advertising.\n\n```\n./scanner.py -c 39 -e -r -50\n```\n\n## Obtaining the IRK\n\nIf you have a rooted Android phone, you can find IRKs (and LTKs) in the Bluedroid\nconfiguration file. On Android 8.1, this is located at `/data/misc/bluedroid/bt_config.conf`.\nThe `LE_LOCAL_KEY_IRK` specifies the Android device's own IRK, and the first 16\nbytes of `LE_KEY_PID` for every bonded device in the file indicate the bonded\ndevice's IRK. Be aware that keys stored in this file are little endian, so\n**the byte order of keys in this file will need to be reversed.** For example,\nthe little endian IRK 22BC0E3F2EACF08EE36B865553EA0B4E needs to be changed to\n4E0BEA5355866BE38EF0AC2E3F0EBC22 (big endian) when being passed to Sniffle with\nthe `-i` option.\n"